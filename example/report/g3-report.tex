\documentclass[titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[danish]{babel}
\usepackage{amsmath}
\usepackage{ulem}
\usepackage{palatino}
\linespread{1.05}
\title{Operativsystemer og Multiprogrammering\\G-opgave 3}
\author{Ronni Elken Lindsgaard - 0911831791 \and
Hans-Kristian Bjerregaard - 0612862087 \and
Alexander Uldall Winther - 2908872013}
\date{09. marts, 2010}
\begin{document}
\maketitle
\newpage
Min kode er selvdokumenterende!
\section{Switch og yield}
Switch sørger for at tage det nuværende job og lægger det over i køen specificeret af {\tt old}. Før
dette sker bliver staten opdateret til det argument som gives. Herefter tages det første element fra 
{\tt new} og dette sættes til current. Den gamle current værdi beholdes vha. en temporær variabel da
den efterfølgende skal bruges i swapcontext som bytter stakken ud.
{\tt switch\_thread} bruges gennegående i koden når to tråde skal skiftes. Ved {\tt othread\_yield}
bruges {\tt switch\_thread} til at lægge current bagest i køen og tage det første element i køen og
sætte til current. 
\section{Mutex}
\subsection{othread.h}
I headerfilen er defineret en struktur for mutexen og samtidig en initialisator. Mutexens struktur
består af et heltal som definerer om værdien er låst eller ej sammen med en liste over evt. jobs som
venter på at mutexen låses op.

Initialisatoren initialiserer, som navnet angiver, en mutex ved at sætte mutexen til at være ulåst
og uden ventende jobs.
\subsection{othread.c}
\subsubsection{\tt mutex\_lock}
Der er 2 tilfælde, låst og ulåst. Hvis mutexen ikke er låst bliver den sat til at være låst og
jobbet får lov at fortsætte.
Er mutexen allerede låst sættes dens status til at være {\tt WAITING} og flyttes over i mutexens
førnævnte waiting-kø ved hjælp af switch\_thread.
\subsubsection{\tt mutex\_unlock}
Mutex unlock tjekker om der er jobs der venter i mutexens waiting-kø, er det tilfældet tages det
første element ud af mutexens waiting kø, dens state sættes til {\tt READY} og indsættes i
ready-køen.

\section{Hukommelse}
Det er lykkedes os at reducere tab af hukommelse til et minimum. Hver gang der hentes et element ud
med {\tt dlink\_remove} bliver dette sat ind med {\tt dlink\_insert}. Vi mener at den tabte
hukommelse enten skyldes den udleverede kode eller variable som vi ikke kan {\it free}'e da disse
variable er globale.

\section{Afvikling}
De udleverede programmer er blevet kørt som forventet. Vi har håndkørt programmerne for at tjekke at
det output vi får er korrekt og vi har samtidig prøvet at ændre på værdier for kørsler (f.eks. ændre
param.c således at ikke alle tråde kører lige mange gange).

\end{document}

