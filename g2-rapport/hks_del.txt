\section{Trådbeskyttet arbejdskø}
  \subsection{Pririoritetskøen}
    Vi har valgt at minimere den krittiske region så meget som muligt og har derved implementeret selve trådsikingen helt inde i pririoritetskøen {\tt pqueue.c}.
    Dette ændrer ikke på selve måden programmet opfører sig på men sikrer at alt brug af pqueue er trådsikret.
    Ved kun at implementerer trådsikringen hvor det er aller mest nødvendigt kan en optimal mængde kode køres paralelt samtidig med at men får et simplere og mere gennemgående design (man skal f.eks. ikke huske at bruge specielle, trådsikrede funktioner når man arbejder på køen).

    Selve implementeringen sker ved at en process tilegner sig en lås så snart den vil arbejde med den linkede liste der er kernen i pririoritetskøen.
    For {\tt pqueue_insert()} gælder det når der scannes igennem listen for at finde den korrekte position samt når elementet reelt set indsættes. 
    Der behøver dog ikke tilegne sig låsen når man allokerer hukommelse og gemmer informationer om det element der skal indsættes.
    Næsten hele {\tt pqueue_remove()} skal trådsikres da den kun arbejder med den linkede liste.

  \subsection{}
    {\tt wqueue_ts_insert} skal således ikke indeholde nogen trådsikring.
    Derfor skal der blot signaleres til evt. ventende tråde hvis indsætningen lykkedes.

    {\tt wqueue_thread_pool} implementeres simpelt ved at modtage en arbejdskø, der allerede indeholder arbejde, og så oprette tråde til at udføre arbejdet.
    Hver tråd modtager en struct med dens arbejdskø samt id (dette er ikke tråd id'et!).
    Efter alle tråde er oprettet begynder {\tt wqueue_thread_pool} at joine dem igen efterhånden som de terminerer.

    Selve trådens arbejde bliver udført af {\tt wqueue_thread}.
    Hver tråd kører så længe der er andre tråde der er ved at udføre et stykke arbejde eller der stadig er arbejde i køen.
    Når der skal udføres et arbejde opdateres arbejdstælleren {\tt threads_working}, arbejdet udføres og arbejdstælleren dekrementeres igen.
    Ændring ef arbejdstælleren er selvfølgeligt sikret med en lås da det er krittisk at den er korrekt.
    Her efter kunne tråden potientielt fortsætte loopet men dette ville kræve en overflødige masse recourcer hele tiden at tjekke tæller og arbejdskø.
    Derfor undersøges der om køen er tom og om der er andre der arbejder.
    Er køen ikke tom gentages loopet for at udføre mere arbejde, ellers, hvis der er andre processer der arbejder, begynder den nuværende process at vente på signal om at der er indsat nyt arbejde i køen.
    Er der ikke mere i køen og er der ikke flere processer der arbejder afsluttes løkken og tråden terminerer.

    Dog skal man være opmærksom på at der er tråde der ender i en potientiel dead-lock ved tråde der venter på et signal der måske aldrig bliver sendt.
    Det er jo ikke til at forudsige om arbejdsfunktionerne indsætter arbejde i køen eller ej.
    Denne dead-lock situation kan dog nemt undgås ved at alle tråde lige inden de terminerer også sender et signal.
    Når en tråd terminerer vil en af de tråde der venter på signal så fortsætte, og selv terminerer da der ikke er mere data i køen og ikke mere arbejde tilbage.
    Det er sikret at der altid er en tråd der terminerer da den sidste tråd der ikke er i dead-lock altid vil detektere at ingen andre arbejder og hvis den selv har udført det sidste arbejde må den terminere.
    Derved undgås dead-lock ved at lade trådene signalere når de terminerer.
  
